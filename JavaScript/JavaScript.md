# JavaScript



## 1. 概览

|          | 红宝书                    | ES6      |
| -------- | ------------------------- | -------- |
| 面向对象 | 3.4  =>  4  =>  5.1  => 6 | 4  =>  9 |
| 函数     | 3.7  => 5.5  =>  7        | 3        |
| Promise  |                           |          |

 



## 2. 面向对象

简单/基本数据类型：undefined、null、boolean、number、string

复杂数据类型：object

### 2.1 typeof 

对一个值使用typeof操作符，可能得到下面结果之一：

* undefined  未定义
* boolean    
* number
* string
* object  这个值是object或者null
* function  

> typeof null 为什么是object？ https://learnku.com/articles/29948

> 0.1 + 0.2 为什么得不到0.3？

### 3.4.7  Object类型

对象其实是一组数据和功能的**集合**。

对象可以通过 `new` 操作符后跟要创建的对象类型的名称来创建。

Object的每个实例都具有下列的方法和属性：

* constructor: 保存创建当前对象的函数
* hasOwnProperty(propertyName)：用于检查给定属性在当前对象实例中
* isPrototypeOf(object)：用于检查传入对象是否传入对象的原型
* propertyIsEnumerable(propertyName)：用于检查给定的属性是否可以用 `for-in` 枚举
* toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应
* toString()：返回对象的字符串表示
* valueOf()：返回对象的字符串、数值或布尔值表示。通常与 `toString()`  方法的返回值相同。

## 4. 变量、作用域和内存问题

执行环境定义了变量或者函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。

**全局执行环境**是最外层的一个执行环境。宿主环境不同，全局环境也不同。Web浏览器中它是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境的所有代码执行完毕后，该环境被销毁，保存在其中的变量和函数定义也随之销毁。（全局执行环境直到浏应用程序退出--浏览器关闭才会被销毁）。

每个函数都有自己的**执行环境**。当执行流进入一个函数时，函数的环境就会被推入一个执行栈当中。而在该函数执行完毕后，栈将其环境弹出，把控制权交给之前的执行环境。

当代码在一个环境中执行的时候，会创建变量对象的一个**作用域链**，它的目的是保证对执行环境有权访问的所有变量和函数的有序执行。作用域链的最前端，始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，那么将其**活动对象**作为变量对象。活动对象在最开始只有一个变量arguments对象。作用域链中的下一个变量对象来自外部包含环境，再下一个则是下一个包含环境。这样一直延续到全局执行环境；全局执行环境对象始终是作用域链的最后一个对象。

### 4.3 垃圾收集

* 标记清除：当变量进入环境时，就将这个变量记为“进入环境”，当变量离开环境则标记为“离开环境”。垃圾收集器会将内存中的所有变量都加上标记。然后去掉环境中的变量以及被环境中的变量所引用的变量的标记。在此之后再被加上标记的变量都被视为准备删除的变量，因为环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除的工作，销毁那些带标记的值并回收其占有的内存空间。
* 引用计数：跟踪记录每个值被引用的次数。当这个值的引用次数变成0时就可以将其占用空间回收。但是这种方法不适用于循环引用。



## 5 引用类型



